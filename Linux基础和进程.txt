Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-02-10T14:39:36+08:00

====== Linux基础和进程 ======
Created 星期五 10 二月 2017

__进程是操作系统分配内存、CPU时间片等资源的基本单位__
__进程是资源分配的最小单位__

进程是操作系统对资源的一种抽象，一个进程：代码段、数据段、堆栈段、进程控制块（PCB)
PCB是操作系统感知进程存在的一个重要数据结构（CPU通过进程控制块来控制进程）


=== 进程数据结构： ===
1.进程的静态描述：由三部分组成：PCB、有关程序段和该程序段对其进行操作的数据结构集
2.进程控制块：用于描述进程情况及控制进程运行所需的全部信息
3.代码段：是进程中能被进程调度在CPU上执行的程序代码段
4，数据段：一个进程的数据段，可以使进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据

=== Linux 内核中的进程状态（就绪、等待/阻塞、运行） ===
1.运行状态 2.可中断睡眠状态 3.不可中断睡眠状态 4.暂停状态 5.僵死状态

=== fork 系统调用 ===
1.使用fork函数得到的紫禁城从父进程继承了整个进程的地址空间，包括：进程上下文，进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
2.子进程和父进程的区别在于：
			a:父进程设置的锁，子进程不继承
			b:各自的进程ID和父进程ID不同
			c:自己成的未决告警被清除
			d:子进程的未决信号机设置为空集


=== 理解一次调用 二次返回 ===
	__问题本质：两次返回，实在各自的进程空中返回的__
	子进程和父进程有自己的内存空间（fork：代码段、数据段、堆栈段、PCB进程控制块的copy）
	
	int main()
	{
		fork(); 
		fork(); 
		fork();
		printf("hello…..\n");
		return 0;
	}
	打印了8次  ------2的3次方
	循环执行n次后总共有2的n次方个进程，新进程数则为2的n次方减1.
	

=== 孤儿进程和僵尸进程 ===

	1.如果父进程先退出，子进程还没退出那么子进程的父进程讲变为init进程（任何一个进程都必须有父进程）
	2.如果子进程先退出，父进程还没退出。那么子进程必须等到父进程捕获到了自己成的退出状态才真正结束，否则这个时候子进程就会成为僵尸进程。
	

=== fork之后又父子进程共享文件 ===
	如果父进程中打开了一个文件，那么子进程不需要再打开


=== fork和vfork ===
	在fork还没实现copy on write之前，Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费所以有了vfork
	
	1.fork子进程拷贝父进程的数据段
		vfork子进程与父进程共享数据段
	2.fork 父、子进程与父进程共享数据段
		vfork：子进程先运行，父进程后运行。	
		
   Vfork和exec函数族在一起
   execve替换进程映像（加载程序）注意execve是一个系统调用;
   替换意味着：代码段、数据段、堆栈段、进程控制块PCB全部替换。
 

=== exit和_exit区别 ===
	1. _exit是一个系统调用 exit是一个c库函数
	2. exit会执行清除I/O缓存
	3. exit会执行调用终止处理程序


=== exec函数族替换进程映像 ===
	功能用exec函数可以把当前进程替换为一个新的进程。exec名下是由多个关联函数组成的一个完整系列 头文件<unistd.h>

	原型：  
	 int execl(const char *path, const char *arg, ...);  
	 函数描述：加载一个进程，通过路径 + 程序名来加载。
	 函数参数：
		path：程序路径+程序名字  
		arg：可执行程序的相关参数，使用NULL结尾 
		返回值：
		成功：无返回
		失败：-1 
		子进程执行指定目录下的自己编写的程序，该程序参数 
		printf("this is func +++++++++ execl +++++++++\n");
		execl("/home/robin/a.out", "a.out", NULL); 
		
		
		int execlp(const char *file, const char *arg, ...);    
		函数描述：加载一个进程，借助PATH环境变量，该函数需要配合PATH环境变量来使用
		当PATH中所有目录搜索后没有参数1则出错
		返回函数参数：可执行程序的相关参数，使用NULL结尾 
		file：可执行程序的名字  
		arg：可执行程序的相关参数，使用NULL结尾  
		返回值：
		成功：无返回 
		失败：-1 
		execlp("ls", "ls", "-la", NULL); 
		
		库函数execlp和execvp使用PATH环境变量，查找第一个包含名为filename的可执行文件的路径名前缀
		
	重点是:execlp、execvp、execle
	a.path参数表示你要启动程序的名称包含路径名
	b.arg参数表示启动程序所带的参数
	c.返回值：成功返回0.失败返回-1
	
	execl execlp execle 都带l 的参数个数是可变的  第二个参数是无用参数“随便写” 最后一个参数以一个空指针结束（NULL）《哨兵》
	
=== 父进程wait和waitpid ===
	
	1、wait和waitpid出现的原因
	SIGCHLD
	当子进程退出的时候，内核会向父进程发送SIGCHLD信号，子进程的退出是个异步事件（子进程可以在父进程运行的任何时刻终止）
	
	子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态。
	父进程查询子进程的退出状态可以用wait/waitpid函数
	
	2、wait和waitpid函数用法
	Wait
	
	头文件<sys/types.h>和<sys/wait.h>
	函数功能:当我们用fork启动一个进程时，子进程就有了自己的生命，并将独立地运行。有时，我们需要知道某个子进程是否已经结束了，我们可以通过wait安排父进程在子进程结束之后。
	
	函数原型
	pid_t wait(int *status) 
	
	函数参数
	status:该参数可以获得你等待子进程的信息
	
	返回值：
	成功等待子进程函数返回，返回值是等待子进程的ID
	
	wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。
	返回的是子进程的PID，它通常是结束的子进程
	
	状态信息允许父进程判定子进程的退出状态，即从子进程的main函数返回的值或子进程中exit语句的退出码。
	如果status不是一个空指针，状态信息将被写入它指向的位置

	Wait获取status后检测处理		宏定义	描述		WIFEXITED(status)	如果子进程正常结束，返回一个非零值		WEXITSTATUS(status)	如果WIFEXITED非零，返回子进程退出码		WIFSIGNALED(status)	子进程因为捕获信号而终止，返回非零值		WTERMSIG(status)	如果WIFSIGNALED非零，返回信号代码		WIFSTOPPED(status)	如果子进程被暂停，返回一个非零值		WSTOPSIG(status)	如果WIFSTOPPED非零，返回一个信号代码
	
	waitoid		(函数功能:用来等待某个特定进程的结束
			(函数原型:			 pid_t waitpid(pid_t pid, int *status,int options)
			 (参数:		status:如果不是空，会把状态信息写到它指向的位置
			(options：允许改变waitpid的行为，最有用的一个选项是WNOHANG,它的作用是防止waitpid把调用者的执行挂起
			返回值：如果成功返回等待子进程的ID，失败返回-1				对于waitpid的p I d参数的解释与其值有关：
			pid == -1 等待任一子进程。于是在这一功能方面waitpid与wait等效。		pid > 0 等待其进程I D与p I d相等的子进程。		pid == 0 等待其组I D等于调用进程的组I D的任一子进程。换句话说是与调用者进程同在一个组的进程。		pid < -1 等待其组I D等于p I d的绝对值的任一子进程。				3、wait pk waitpid		Wait和waitpid区别和联系
			在一个子进程终止前， wait 使其调用者阻塞，而waitpid 有一选择项，可使调用者不阻塞。		waitpid并不等待第一个终止的子进程—它有若干个选择项，可以控制它所等待的特定进程。		实际上wait函数是waitpid函数的一个特例。				僵尸进程		当一个子进程结束运行时，它与其父进程之间的关联还会保持到父进程也正常地结束运行或者父进程调用了wait才告终止。		进程表中代表子进程的数据项是不会立刻释放的，虽然不再活跃了，可子进程还停留在系统里，因为它的退出码还需要保存起来以备父进程中后续的wait调用使用。它将称为一个“僵进程”		如何避免僵尸进程		调用wait或者waitpid函数查询子进程退出状态，此方法父进程会被挂起。		如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。
	
=== 守护进程（daemon 精灵进程） ===

	概念
		1.守护进程实在后台有UN性不收控制终端控制的进程，通常情况下守护进程在系统启动时自动运行
		2.守护进程的名称通常以d结尾。
		
	创建守护进程步骤:
		1.调用fork（），创建新进程，他会是将来的守护进程
		2.在父进程中调用exit，保证子进程不是进程组组长
		3.调用setsid创建新的绘画期
		4.讲当前目录改为根目录（如果把当前目录作为守护进程的目录，当前目录不能被卸载，它作为守护进程的工作目录了。）
		5.讲标准输入、标准输出、标准错误重定向到/dev/null（无底洞）
		
		
		守护进程宏函数写法：
		
		#define INIT_DAEMON \
		{ \
			if(fork() >0) exit(0); \
			setsid(); \
			if(fork()>0) exit(0); \
		}



























	










































































